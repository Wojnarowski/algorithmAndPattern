package leetcode.everyday.commit2021.may;

/**
 *q 810 黑板异或游戏
 *
 * 黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，
 * Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，
 * 当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）
 *
 * 换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。
 *
 * 假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。
 *
 *  
 *
 * 示例：
 *
 * 输入: nums = [1, 1, 2]
 * 输出: false
 * 解释:
 * Alice 有两个选择: 擦掉数字 1 或 2。
 * 如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。
 * 如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。
 *
 * 提示：
 *
 * 1 <= N <= 1000
 * 0 <= nums[i] <= 2^16
 * 通过次数10,520提交次数14,691
 *
 *  
 *
 *
 */
public class Solution_20210522_810 {

    /**
     * 博弈论题
     * 博弈论
     * 对于本题，给定的是判断「胜利」的规则（在给定序列的情况下，如果所有数值异或和为 00 可立即判断胜利，其他情况无法立即判断胜负），那么我们应该优先判断何为「先手必胜态」，如果不好分析，才考虑分析后手的「必败态」。
     *
     * 接下来是分情况讨论：
     *
     * 1. 如果给定的序列异或和为 00，游戏开始时，先手直接获胜：
     * 由此推导出性质一：给定序列 nums 的异或和为 00，先手处于「必胜态」，返回 True。
     *
     * 2. 如果给定序列异或和不为 00，我们需要分析，先手获胜的话，序列会满足何种性质：
     * 显然如果要先手获胜，则需要满足「先手去掉一个数，剩余数值异或和必然不为 00；同时后手去掉一个数后，剩余数值异或和必然为 00」。
     *
     * 换句话说，我们需要分析什么情况下「经过一次后手操作」后，序列会以上述情况 11 的状态，回到先手的局面。
     *
     * 也就是反过来分析想要出现「后手必败态」，序列会有何种性质。
     *
     * 假设后手操作前的异或和为 SumSum（Sum \neq 0Sum
     * 
     * ​
     *  =0），「后手必败态」意味着去掉任意数字后异或和为 00。
     *
     * 同时根据「相同数值异或结果为 00」的特性，我们知道去掉某个数值，等价于在原有异或和的基础上异或上这个值。
     *
     * 则有：
     *
     * Sum' = Sum ⊕ nums[i] = 0
     * Sum
     * ′
     *  =Sum⊕nums[i]=0
     *
     * 由于是「后手必败态」，因此 ii 取任意一位，都满足上述式子。
     *
     * 则有：
     *
     * Sum ⊕ nums[0] = ... = Sum ⊕ nums[k] = ... = Sum ⊕ nums[n - 1] = 0
     * Sum⊕nums[0]=...=Sum⊕nums[k]=...=Sum⊕nums[n−1]=0
     *
     * 同时根据「任意数值与 00 异或数值不变」的特性，我们将每一项进行异或：
     *
     * (Sum ⊕ nums[0]) ⊕ ... ⊕ (Sum ⊕ nums[k]) ⊕ ... ⊕ (Sum ⊕ nums[n - 1]) = 0
     * (Sum⊕nums[0])⊕...⊕(Sum⊕nums[k])⊕...⊕(Sum⊕nums[n−1])=0
     *
     * 根据交换律进行变换：
     *
     * (Sum ⊕ Sum ⊕ ... ⊕ Sum) ⊕ (nums[0] ⊕ ... ⊕ nums[k] ⊕ ... ⊕ nums[n - 1]) = 0
     * (Sum⊕Sum⊕...⊕Sum)⊕(nums[0]⊕...⊕nums[k]⊕...⊕nums[n−1])=0
     *
     * 再结合 SumSum 为原序列的异或和可得：
     *
     * (Sum ⊕ Sum ⊕ ... ⊕ Sum) ⊕ Sum = 0 , Sum \neq 0
     * (Sum⊕Sum⊕...⊕Sum)⊕Sum=0,Sum
     * 
     * ​
     *  =0
     *
     * 至此，我们分析出当处于「后手必败态」时，去掉任意一个数值会满足上述式子。
     *
     * 根据「相同数值偶数次异或结果为 00」的特性，可推导出「后手必败态」会导致交回到先手的序列个数为偶数，由此推导后手操作前序列个数为奇数，后手操作前一个回合先手为偶数。
     *
     * 由此推导出性质二：只需要保证先手操作前序列个数为偶数时就会出现「后手必败态」，从而确保先手必胜。
     *
     * 综上，如果序列 nums 本身异或和为 00，天然符合「先手必胜态」的条件，答案返回 True ；如果序列 nums 异或和不为 00，但序列长度为偶数，那么最终会出现「后手必败态」，推导出先手必胜，答案返回 True。
     *
     * @param nums
     * @return
     */
    public boolean xorGame(int[] nums) {
        int sum = 0;
        for (int i : nums) sum ^= i;
        return sum == 0 || nums.length % 2 == 0;
    }

    public static void main(String[] args) {
        System.out.println("-------------开始执行-------------");
        //Assert.isTrue(topKFrequent(new String[]{"i", "love", "leetcode", "i", "love", "coding"},2)==28,"程序异常");
        //topKFrequent(new String[]{"i", "love", "leetcode", "i", "love", "coding"},2);
        System.out.println("-------------运行通过-------------");
    }
}
